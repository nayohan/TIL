# 배열

[TOC]


## 1. 배열
배열은 여러 개의 동일한 데이터 타입의 데이터를 한번에 만들 때 사용된다. 

```
int A[6] = {1, 2, 3, 4, 5, 6};
int B[2][3] = {{1, 2, 3}, {4, 5, 6}};
```

배열을 사용하면 인덱스(index) 번호를 기준으로 작업을 할 수 잇기 때문에 인덱스 번호에 따라 효율적으로 루프를 설정하여 여러 상황에서 간단한 코드를 이용하여 결과를 나타낼 수 있다.  여러가지 상황에서 효율적으로 프로그램을 작성할 수 있다.

배열의 가장 기본적인 특징은 배열은 <인덱스, 요소> 쌍의 집합이라는 것이다. 즉 인덱스가 주어지면 해당하는 요소(elment)가 대응되는 자료 구조이다. 배열에서는 인덱스를 사용하여 요소에 직접 접근한다. 배열이 기본적으로 제공되어 있지 않다고 가정하고, 배열을 **추상데이터 타입**으로 정의하여 보자. 

### 1.1. ADT Array

```
  - 객체: <인덱스, 요소> 쌍의 집합
  - 연산:
  		create(n) ::= n개의 요소를 가진 배열의 생성
  		retrieve(A, i) ::= 배열 A의 i번째 요소 반환
  		store(A, i, item) ::= 배열의 A의 i번째 위치에 item 저장.  
```



### 1.2. 배열응용: 다항식의 덧셈

수학에서 나오는 다항식을 배열을 이용하여 표현해보자. 다항식의 일반적인 형태는 다음과 같다.
$$
p(x) = a_nx^n + a_{n-1}x^{n-1} + \cdot\cdot\cdot + a_1x + a_0
$$
위의 다항식에서 a: 계수, x: 변수, n:지수라 부른다. 위의 다항식을 프로그램 안에서 표현하려고 하면 두 가지 방법을 생각할 수 있다.

#### 1.2.1. 첫번째 방법

$$
10x^5 + 0 \cdot x^4 + 0 \cdot x^3 + 0 \cdot x^2 + 6x +3
$$
모든 차수에 대한 계수값들의 리스트인 {10, 0, 0, 0, 6, 3}을  배열  coef에 저장하는 것이다. 그리고 최고차수의 항을   degree에 저장한다.

##### 1.2.1.1. 구조체 생성

```c
#define MAX_DEGREE = 101
typedef struct {
	int degree;
	float coef[MAX_DEGREE];
} polynomial;
polynomial a = { 5, {1, 2, 3, 4, 5, 6} };
```

위의 방법의 문제점은 다항식의 대부분의 한의 계수가 0인 희소 다항식의 경우에는 공간낭비가 심하다는 것이다. 이 방법의 장점은 다항식의 덧셈이나 뺄셈시에 같은 차수의 계수를 쉽게 찾을수 있으므로 알고리즘이 간단해진다는 것이다.

##### 1.2.1.2. 알고리즘

이 방법으로 표현된 2개의 다항식을 받아서 덧셈을 하는 프로그램을 만들어보자. 최고차항부터 배열이 차례로 저장되어 있음을 유의해야 한다. 구조체  A,B의 coef배열을 스캔하면서 차수가 큰 한을 구조체  C로 이동한다. 차수가 같으면 구조체 A,B의 coef 배열 값을 더하여 C의  coef에 대입한다. 두개의 다항식 모두 차수가 최고차항에서  0까지 존재하므로 while루프가 끝다면 모든 항들이 처리되는 것이 보장된다.

```
   1. polynomial 구조체 생성 -> 다항식의 차수 int degree / 계수를 담을 배열 float coef[MAX_DEGREE]
   2. polynomial 구조체 a, b, c 선언
   3. 함수 poly_add1(polynomial a, polynomail b) 생성
   		3.1. 배열의 인덱스 apos, bpos, cpos -> 0
        3.2. 다항식의 차수 degree_a, degree_b, degree_c -> A.degree, B.degree, MAX(A.degree, B.degree)
        3.3. degree가 높은것부터 차례로 --해가면서 C.coef[Cpos]에 삽입.
        3.4. while(Apos<=A.degree && Bpos<=B.degree)
        		{A항>B항일때 c=a,  A항==B항일때 c=a+b, A항<B항 c=b}
   4. c = poly_add1(a,b)
```

##### 1.2.1.3. 코드

```c
#include <stdio.h>
#define MAX(a,b) ((a)>(b) ? (a):(b))
#define MAX_DEGREE 101
typedef struct {
	int degree;
	float coef[MAX_DEGREE];
}polynomial;

polynomial poly_add1(polynomial A, polynomial B) {
	polynomial c;
	int Apos = 0, Bpos = 0, Cpos = 0;
	int degree_a = A.degree;
	int degree_b = B.degree;
	
	c.degree = MAX(A.degree, B.degree);

	while (Apos <= A.degree && Bpos <= B.degree) {
		if (degree_a > degree_b) {
			c.coef[Cpos++] = A.coef[Apos++];
			degree_a--;
		}

		if (degree_a == degree_b) {
			c.coef[Cpos++] = A.coef[Apos++] + B.coef[Bpos++];
			degree_a--;
			degree_b--;
		}

		if (degree_a < degree_b) {
			c.coef[Cpos++] = B.coef[Bpos++];
			degree_b--;
		}
	}
	return c;
}
int main() {
	polynomial a = { 5, {3, 6, 0, 0, 0, 10} };
	polynomial b = { 4, {7, 0, 5, 0, 1} };

	polynomial c;
	c = poly_add1(a, b);
	printf("%d\n", c.degree);
	for (int i = 0; i <= c.degree; i++) {
		printf("%f ", c.coef[i]);
	}
}
```



#### 1.2.2. 두번째 방법

첫번째 방법의 가장 큰 단점이 공간을 절약하기 위하여 다항식에서 0이 아닌 항만을 하나의 전역 배열에 저장하는 방법도 생각할 수 있다. 다항식의 0이 아닌 항들은 (계수, 차수) 의 형식으로 표시하는 방법이 있다.

이방법을 이용하여 다항식을 표현해보자.
$$
A = 8x^3 + 7x +1,  B = 10x^3 + 3x^2 + 1
$$

##### 1.2.2.1. 구조체 생성

```
#define MAX_TERMS 101
struct {
    float coef;
    int expon;    
} terms[MAX_TERMS] =  {{8,3}, {7,1}, {1,0}, {10,3}, {3,2}, {1,0}};
```

이방법을 

